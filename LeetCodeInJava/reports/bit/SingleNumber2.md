
方法1：创建一个长度为sizeof(int)的数组count\[sizeof(int)\]，count\[i\]表示在在i位出现的1的次数。如果count\[i\]是3的整数倍，则忽略；否则就把该位取出来组成答案。

方法2：用one记录到当前处理的元素为止，二进制1出现“1次”（mod 3 之后的 1）的有哪些二进制位；用two记录到当前计算的变量为止，二进制1出现“2次”（mod 3 之后的 2）的有哪些二进制位。当one和two中的某一位同时为1时表示该二进制位上1出现了3次，此时需要清零。即用二进制模拟三进制运算。最终one记录的是最终结果。

0xffffffff 是-1 补码表示  即
```
[1111 1111 1111 1111]补
= [1111 1111 1111 1110]反
= [1000 0000 0000 0001]原
= -1
```

0x7fffffff 是int的最大值
```
[0111 1111 1111 1111]补
```
除符号位的最大值，java没有无符号整数

所以 ~0 的补码是
```
[1111 1111 1111 1111]补
```


```
[1000 0000 …… 0000 0000]补
= -2^31
= -2147483648
```

#### Solution4
我们这里的ab就是上面的三种状态00，01，10的十位和各位，刚开始的时候，a和b都是0，当此时遇到数字1的时候，b更新为1，a更新为0，就是01的状态；再次遇到1的时候，b更新为0，a更新为1，就是10的状态；再次遇到1的时候，b更新为0，a更新为0，就是00的状态，相当于重置了；最后的结果保存在b中。明白了上面的分析过程，就能写出代码如下；

