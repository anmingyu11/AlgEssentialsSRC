## 切钢条

>**动态规划是付出额外的内存控件来节省计算时间，是典型的时空权衡的例子。而时间上的节省是巨大的：可能将一个指数时间的解转化为一个多项式时间的解。如果子问题的数量是输入规模的多项式函数，而我们可以在多项式时间内求解出每个子问题，那么动态规划的总运行时间就是多项式阶的。**

问题描述:
给定一段长度为n英寸的钢条和一个价格表pi(i=1,2,...,n),求钢条切割方案，使得销售收益rn最大。
注意，如果长度为n英寸的钢条价格pn足够大，最优解可能就是完全不需要切割

价格表

|长度i|1|2|3|4|5|6|7|8|9|10|
|--|--|--|--|--|--|--|--|--|--|--|
|价格pi|1|5|8|9|10|17|17|20|24|30|

长度为n英寸的钢条共有`2^n-1`种不同的切割方案，因为在距离钢条左端i(i=1,2,...,n-1)英寸处，我们总是可以选择切割或不切割。我们用普通的加法符号表示切割方案，因此7=2+2+3表示将长度为7英寸的钢条分割为三段——两端长度为2英寸，一段长度为3英寸。
股如果一个最优解为将钢条切割为k段(对于某个1<=k<=n),那么最优切割方案:
```
n = i1 + i2 + ... + ik
```
将钢条切割为长度分别为i1,i2,...ik的小段，得到最大收益
```
rn = pi1 + pi2 + ... + pik
```

第一个参数pn对应不切割，直接出售长度为n英寸的钢条的方案。其他n-1个参数对应另外n-1种方案：对每个i=1,2,...,n-1，首先将钢条切割为长度为i和n-i的两段，接着求解这两段的最优切割收益ri和r(n-i）(每种方案的最优收益为两段的最优收益之和)。由于无法预知哪种方案会获得最优收益，我们必须考察所有可能的i，选区其中收益最大者。如果直接出售原钢条获得最大收益，我们当然可以选择不做任何切割。

注意到，为了求解规模为n的原问题，我们先求解形式完全一样，但规模更小的子问题。即当完成首次切割后，我们将两段钢条看成两个独立的钢条切割问题实例。

>**我们通过组合两个相关子问题的最优解，并在所有可能的两段切割方案中选取组合收益最大者，构成原问题的最优解。我们称钢条切割问题满足最优子结构性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。**

除了上述求解方法外，钢条切割问题还存在一种相似的但更为简单的递归求解方法：我们将钢条左边切割下长度为i的一段，只对右边剩下的长度为n-i的一段继续进行切割(递归求解)，对左边的一段则不再进行切割。即问题分解的方式为：将长度为n的钢条分解为左边开始一段，以及剩余部分继续分解的结果。这样，不做任何切割的方案就可以描述为：
第一段的长度为n，收益为pn,剩余部分长度为0，对应的收益为r0=0。于是我们可以得到公式的简化版本:
```
rn = max(pi + r(n-i))
```

> **动态规划有两种等价的实现方法，下面以钢条切割问题为例展示这两种方法。**

> **第一种方法称为带备忘的自顶向下法。此方法仍按自然的递归形式编写过程，但过程会保存每个问题的解(通常保存在一个数组或散列表中)。当需要一个子问题的解时，过程首先检查是否已经保存过此解。如果是，则直接返回保存的值，从而节省了计算时间；否则，按通常方式计算这个子问题。我们称这个递归过程是带备忘的，因为它“记住”了之前已经计算出的结果。**

> **第二种方法称为自底向上法。这种方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的”子问题的求解。因而我们可以将子问题按规模排序，按由小至大的顺序进行求解。当求解某个子问题时，它所以来的那些更小的子问题都已求解完毕，结构已经保存。每个子问题只需求解一次，当我们求解它时(也是第一次遇到它)时，它的所有前提子问题都已求解完成**

两种方法得到的算法具有相同的渐近运行时间，仅有的差异是在某些特殊情况下，自顶向下法并未真正递归地考察所有可能的子问题。由于没有频繁的递归函数调用的开销，自底向上法的时间复杂性函数通常具有更小的系数。

#### 自顶向下
```
MEMOIZED-CUT-ROD(p,n)
let r[0..n]be a new array
for i = 0 to n
	r[i] = -INF
return MEMOIZED-CUT-ROD-AUX(p,n,r)

MEMOIZED-CUT-ROD-AUX(p,n,r)
if r[n] >= 0
	return r[n]
if n == 0
	q = 0
else
	q = -INF
	for i = 1 to n
		q = max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n-i ,r))
r[n] = q
return q
```

#### 自底向上
```
BOTTOM-UP-CUT-ROD(p,n)
let r[0..n] be a new array
r[0] = 0
for j = 1 to n
	q = -INF
	for i = 1 to j
		q = max(q , p[i] + r[j-i])
	r[j] = q
return r[n]
```

自底向上的动态规划处理子问题图中顶点的顺序为：对于一个给定的子问题x，在求解它之前求解邻接至它的子问题y。换句话说，对于任何子问题，直至它依赖的所有子问题已求解完成，才会求解它，

#### 重构解
```
EXTENDED-BOTTOM-UP-CUT-ROD(p,n)
let r[0...n] and s[0...n] be new arrays
r[0] = 0;

for j = 1 to n
	q = -INF
		for i = 1 to j
			if q < p[i] + r[j-i]
				q = p[i] + r[j-i]
				s[j] = i
			r[j] = q

return r and s
```
