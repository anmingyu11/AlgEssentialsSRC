## 算法基础

### 插入排序

> 算法导论给的例子很形象,就根扑克牌倒腾牌一个道理

循环不变式主要用来帮助我们理解算法的正确性.关于循环不变式,我们必须证明三条性质:

1. 初始化: 循环的第一次迭代之前,它为真
2. 保持: 如果循环的某次迭代之前它为真,那么下次迭代之前它仍为真.
3. 终止: 在循环终止时,不变式为我们提供一个有用的性质,该性质有助于证明算法是正确的.

当前两条性质成立时,在循环的每次迭代之前循环不变式为真.(当然,为了证明循环不变式在每次迭代之前保持为真,我们完全可以使用不同于循环不变式本身的其他已证实的事实.)

**注意,这类似于数学归纳法,其中为了证明某条性质成立,需要证明一个基本情况和一个归纳步.这里,证明第一次迭代之前不变式成立对应于基本情况,证明从一次迭代到下一次迭代不变式成立对应于归纳步.**

第三条性质也许是最重要的,因为我们将使用循环不变式来证明正确性.通常,我们和导致循环终止的条件一起使用循环不变式.终止性不同于我们通常使用数学归纳法的做法,在归纳法中,归纳步是无限地使用的,这里当循环终止时,停止"归纳".

> 插入排序的循环不变式是一个非常典型的归纳证明,其实编程语言中的循环就是数学归纳法的一种具体化形式.

### 分析算法

分析算法的结果意味着预测算法需要的资源.

#### 插入排序算法的分析

过程INSERTION-SORT需要的时间依赖于输入:排序1000个数比排序三个数需要更长的时间.此外,依据它们已被排序的成都,INSERTION-SORT可能需要不同数量的时间来排序两个具有相同规模的输入序列.

### 设计算法

#### 分治法

**许多有用的算法在结构上是递归的:为了解决一个给定的问题,算法一次或多次递归地调用其自身以解决紧密相关的若干子问题.这些算法典型地遵循分治法的思想:将原问题分解为几个规模较小但类似于原问题的子问题,递归地求解这些子问题,然后再合并这些子问题的解来建立原问题的解.**

> 结构上是递归的问题在求解的时候,就类似于星际争霸中的战术,庐山升龙霸,什么意思呢,就是说一旦当你制定好了解决问题的步骤,就不能有智力,因为一个稍微复杂点的递归问题,根普通的迭代解决问题是不一样的,进去细想很容易会怀疑自己,进而钻进死胡同,就要像庐山升龙霸一样,一旦开始走到实现(进攻)这一步的时候,就什么都不能想,一心一意的去重复下面的这三步(1.造蟑螂 2.F2 3.A).

分治模式在每层递归时都有三个步骤:

1. 分解原问题为若干子问题,这些子问题是原问题的规模较小的实例.
2. 解决这些子问题,递归地求解各子问题.然而若子问题的规模足够小,则直接求解.
3. 合并这些子问题的解成原问题的解.

归并排序完全遵循分治模式.

#### 分析分治算法

归并排序算法的分析

分治法的分析:
1. 分解
2. 解决
3. 合并

递归树的总层数为lgn + 1.其中n是叶数,对应于输入规模.
