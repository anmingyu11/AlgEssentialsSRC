## 动态规划原理

在本节中，我们关注适合应用动态规划方法求解的最优化问题应该具备的两个要素：**最优子结构和子问题重叠**。

### 最优子结构

用动态规划方法求解最优化问题的第一步就是刻画最优解的结构。

因此，某个问题是否适合用动态规划算法，它是否具有最优子结构是一个好线索。

你会发现，在发掘最优子结构性质的过程中，实际上遵循了如下的通用模式：

1. **证明问题最优解的第一个组成部分是做出一个选择**，例如，选择钢条第一次切割位置，选择矩阵链的划分位置等。做出这次选择会产生一个或多个待解的子问题。
2. 对于一个给定子问题，在其可能的第一步选择中，你假定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择。
3. 给定可获得最优解的选择后，你确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间。
4. 利用"剪切——粘贴"技术证明：**作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。**

一个刻画子问题空间的好经验是：保持子问题空间尽可能简单，只在必要时才扩展它。

与之相对的，假定我们试图限制矩阵链A1A2...Aj乘法问题的子问题空间。

对于不同问题领域，最优子结构的不同体现在两个方面：

1. 原问题的最优解中涉及多少个子问题，以及
2. 在确定最优解使用哪些子问题时，我们需要考察多少种选择。

在动态规划中，我们通常自底向上地使用最优子结构。
也就是说，首先求得子问题的最优解，然后求原问题的最优解。在求解原问题的过程中，我们需要在涉及的子问题中做出选择，选出能得到原问题最优解的子问题。原问题最优解的代价通常就是子问题最优解的代价再加上由此次选择直接产生的代价。

在第16章中，我们将介绍“贪心法”，它与动态规划有很多相似之处。

### 一些微妙之处

在尝试使用动态规划方法时要小心，要注意问题是否具有最优子结构性质。考虑下面两个问题，其中都是给定一个有向图G=(V, E)和两个顶点 (u,v) <- V

- 无权最短路径：找到一条从u到v的边数最少的路径。这条路径必然是简单路径，因为如果路径中包含环，将环去掉显然会减少边的数量。
- 无权最长路径： 找到一条从u到v的边数最多的简单路径。这里必须加上简单路径的要求，因为我们可以不停地沿着环揍，从而得到任意长的路径。

> 如果路径上的各顶点均不互相重复，称这样的路径为简单路径。如果路径上的第一个顶点与最后一个顶点重合，这样的路径称为回路(cycle)或环或圈。

这里，子问题无关的含义是，同一个原问题的一个子问题的解不影响另一个子问题的解。

### 重叠子问题

适合动态规划方法求解的最优化问题应该具备的第二个性质是子问题空间必须足够“小”，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的问题。

#### 矩阵链乘法的备忘录解法
```
```

### 重构最优解

从实际考虑，我们通常将每个子问题所做的选择存在一个表中，这样就不必根据价值来重构这些信息。

### 备忘

如钢条切割问题中所见，我们可以保持自顶向下策略，同时达到与自底向上动态规划方法相似的效率。思路就是对自然但低效的递归算法加入备忘机制。与自底向上方法一样，我们维护一个表记录子问题的解，但保持递归算法的控制流程。

```
MEMOIZED-MATRIX-CHAIN

LOOKUP-CHAIN
```

下图说明了与RECURSIVE-MATRIX-CHAIN相比，MEMOIZED-MATRIX-CHAIN是如何节省时间的。阴影子树表示那些直接查表获得而非重新计算的值。

通常情况下，如果每个子问题都必须至少求解一次，自底向上动态规划算法会比自顶向下备忘算法快（都是O(n^3)时间，相差一个常量系数），因为自底向上算法没有递归调用开销，表的维护开销也更小。而且对于某些问题，我们可以利用表的访问模式来进一步降低时空代价。
