## 加权有向图的数据结构
### 最短路径定义:
在一副加权有向图中,从顶点s到顶点t的最短路径是所有从s到t的路径中的权重最小者.

单点最短路径:
给定一副加权有向图和一个起点s,回答"从s到给定目的顶点v是否存在一条有向路径",如果有,找出最短的那条路径

### 最短路径的性质
- 路径是有向的
- 权重不一定等价于距离
- 并不是所有顶点都是可达的(为了简化问题,我们的样图都是强连通的)
- 负权重问题会使问题更复杂
- 最短路径一般都是简单的
- 最短路径不一定是唯一的
- 可能存在平行边或自环

### 最短路径树
给定一副加权有向图和一个顶点s,以s为起点的一棵最短路径树是图的一副子图,它包含s和从s可达的所有顶点.这棵有向树的根结点为s,树的每条路径都是有向图的一条最短路径.

这样一棵树是一定存在的:一般来说,从s到一个顶点有可能存在两条长度相等的路径.如果出现这种情况,可以删除其中一条路径的最后一条边.

### API
distTo(int v) //从顶点s到v的距离,如果不存在则为无穷大.
hasPathTo(int v) // 是否存在从顶点s到v的路径.
pathTo(int v) // 从顶点s到v的路径,如果不存在则为null.

### 最短路径的数据结构
- 最短路径树中的边,父链接数组edgeTo[],其中edgeTo[v]的值为树中的连接和它父节点的边(也是从s到v路径上的最后一条边).
- 到达起点的距离.我们需要一个由顶点索引的数组distTo[],其中distTo[v]为从s到v的已知最短路径的长度.

### 边的松弛
放松边v->w意味着检查从s到w的最短路径是否先从s到v,然后再从v到w.如果是,则根据这个情况更新数据结构中的内容.
由v到达w的最短路径是distTo[v]与e.weight()之和

```
if (distTo[w] > distTo[v] + e.weight()) {
    distTo[w] > distTo[v] + e.weight()
    edgeTo[w] = e
}
```

放松一条边就类似于橡皮筋转移到一条更短的路径上,从而缓解了橡皮筋的压力.如果relax()改变了和边e相关的顶点distTo(e.to())和edgeTo[e.to()]的值,就称放松e是成功的.

### 顶点的松弛
注意,从任意distTo[v]为有限值的顶点v指向任意distTo[]为无穷的顶点的边都是有效的.

### 最短路径算法的理论基础

#### 最短路径的最优性条件(定义变量不完全,我日你老母)
令G是一副加权有向图,顶点s是G中的起点,distTo[]是一个由顶点索引的数组,保存的是G中路径的长度.
对于从s可达的所有顶点v,distTo[v]的值是从s到v的**某条**路径的长度,对于从s不可达的所有顶点v,该值为无穷大.
当且仅当对于从v到w的任意一条边e,这些值都满足distTo[w]<=distTo[v] + e.weight()时(换句话说,不存在有效边时),它们是最短路径的长度.

证明:

1. 假设distTo[w]是从s到w的最短路径.
如果对于某条从v到w的边e有distTo[w] > distTo[v] + e.weight(),那么从s到w(经过v)的路径的长度必然小于distTo[w],矛盾.因此最优性条件是必要的.


2. 要证明最优性条件是充分的,假设w是从s可达的且s=v0->v1->v2...->vk=w是从s到w的最短路径,其权重为OPTsw.
对于1到k之间的i,令ei表示vi-1到vi的边.根据最优性条件,可以得到以下不等式:

```
distTo[w] = distTo[vk] <= distTo[vk-1] + ek.weight()
            distTo[vk-1] <= distTo[vk-2] + ek-1.weight()
            ...
            distTo[v2] <= distTo[v1] + e2.weight()
            distTo[v1] <= distTo[s] + e1.weight()
```

综合这些不等式并去掉distTo[s] = 0.0,得到:

distTo[w] = e1.weight() + ... + ek.weight() = OPTsw

现在,distTo[w]为从s到w的某条边的长度,因此它不可能比最短的路径更短.所以以下不等式必然成立.
OPTsw <= distTo[w] <= OPTsw

#### 通用算法
由最优性条件马上可以得到一个能够涵盖已经学习过的所有最短路径算法的通用算法.现在,我们只研究非负权重的情况.

#### 命题Q(通用最短路径算法).将distTo[s]初始化为0,其他distTo[]元素初始化为无穷大,继续如下操作:
放松G中的任意边,直到不存在有效边为止.
对于任意从s可达的顶点w,在进行这些操作之后,distTo[w]的值即为从s到w的最短路径的长度(且edgeTo[w]的值即为该路径上的最后一条边).

证明:
放松边v->w必然会将distTo[w]的值设为从s到w的某条路径的长度(且将edgeTo[w]设为该路径上的最后一条边).
对于从s可达的任意顶点w,只要distTo[w]仍然是无穷大,到达w的最短路径上的某条边肯定仍然是有效的,因此算法的操作会不断继续,
直到由s可达的每个顶点的distTo[]值均变为到达该顶点的某条路径的长度.
**对于已经找到最短路径的任意顶点v,在算法的计算过程中distTo[v]的值都是从s到v的某条(简单)路径的长度且必然是单调递减的.**
因此,它的递减的次数必然是有限的(每切换一条从s到v的简单路径就递减一次).当不存在有效边的时候,命题P就成立了.

### Dijkstra算法
首先将distTo[s]初始化为0,distTo[]中其他元素初始化为正无穷.
**然后将distTo[]最小的非树顶点放松并加入数中,如此这般,直到所有的顶点都在树中或者所有的非树顶点的distTo[]值均为无穷大.**

#### 命题R Dijkstra算法能够解决边**权重非负的加权有向图的单起点最小路径问题**.
证明:如果v是从起点可达的,那么所有v->w的边都会只被放松一次.当v被放松时,必有distTo[w] <= distTo[v] + e.weight().
该不等式在算法结束前都会成立,
因此distTo[w]只会变小(放松操作只会减小distTo[]的值)
而distTo[v]则不会被改变(因为边的权重非负且在每一步算法中都会选择distTo[]最小的顶点,之后的放松操作不可能使任何distTo[]的值小于distTo[v]).
因此,在所有从s可达的顶点均被添加到树中之后,最短路径的最优性条件成立,即命题P成立.

#### 满足最优性条件
要实现Dijkstra算法,除了distTo[]和edgeTo[]数组之外还需要一条索引优先队列pq,以保存**需要被放松的顶点**并确认**下一个被放松的顶点**.

#### 换一个角度看问题
Dijkstra与Prim:
Prim算法每次添加的是离树最近的非树顶点,Dijkstra算法每次添加的都是离起点最近的非树顶点.

#### 变种
Dijkstra算法的实现每次都会为最短路径添加一条边,该边由一个树中的顶点指向一个非树顶点w且它是到s最近的顶点.

**给定两点的最短路径** 给定一副加权有向图以及一个起点和一个终点t,找到从s到t的最短路径.
任意顶点对之间的最短路径.给定一副加权有向图,回答"给定一个起点s和一个终点t,是否存在一条从s到t的路径?"如果有,找出最短的那条

### 无环加权有向图中的最短路径算法
AcyclicSP
比Dijkstra更快,更简单的在无环加权有向图中找出最短路径的算法.
- 能够在线性时间内解决单点最短路径问题
- 能够处理负权重的边
- 能够解决相关的问题,例如找出最长的路径

只要将顶点的放松和拓扑排序结合起来,马上就能够得到一种解决无环加权有向图中的最短路径的算法.
首先初始化distTo[]然后一个一个的按照拓扑顺序放松所有顶点

#### 命题S 按照拓扑顺序放松顶点,就能在E+V成正比的时间内解决无环加权有向图的单点最短路径问题
证明:每条边v-w都只会被放松一次.当v被放松时,得到:distTo[w] <= distTo[v] + e.weight().
在算法结束之前该不等式都成立,因为distTo[v]是不会变化的(**因为是按照拓扑顺序放松顶点,在v放松之后算法不会处理任何指向v的边**)
而distTo[w]只会变小(任何放松操作都只会减小distTo[w]中的元素的值).因此,在所有s可达的顶点都被加入到树中后,最短路径的最优性条件成立,命题Q也就成立了.

无环很重要,因为它的"无环"能够极大地简化问题的论断.
对于最短路径问题,基于拓扑排序的方法比Dijkstra算法快的倍数与Dijkstra算法中所有优先队列的操作的总成本成正比.
另外,命题S的证明和边的权重是否非负无关,因此无环加权有向图不会受到任何限制.下面用这个特点解决边的负权重问题.
我们会考虑使用这个最短路径模型来解决另外两个问题,其中之一乍一看甚至和图的处理没有任何关系.

### 最长路径
实现该类的一个简单方法是修改AcyclicLP类来寻找一副无环加权有向图中的最长路径就十分简单了.
实现该类的一个简单的方法是修改AcyclicSP,将distTo[]的初始值变为Double.NEGATIVE_INFINITY,并改变relax不等式的方向.
无论使用哪种方法,都能得到无环加权有向图中的最长路径问题的一种高效的解决方案.
和它形成鲜明对比的是,在一般的加权有向图中寻找最长简单路径的已知最好方法在最坏的情况下所需的时间是指数级别的!
出现环的可能性似乎使这个问题的难度以指数级别增长.

### 关键路径

### 平行任务调度

#### 定义
**优先级限制下的并行任务调度**:给定一组需要完成的特定任务,以及一组关于任务完成的先后次序的优先级限制.
在满足限制条件的前提下应该如何在若干相同的处理器上(数量不限)安排任务并在最短的时间内完成所有的任务?
定义:解决并行任务调度问题的关键路径方法的步骤如下,
创建一副无环有向图,其中包含一个起点s和一个终点t且每个任务都对应着两个顶点(一个起始顶点和一个结束顶点).
对于每个任务都有一条从它的起始顶点指向结束顶点的边,边的权重为任务所需的时间.
对于每条每条优先级限制v->w,添加一条从v的结束顶点指向w的起始顶点的权重为0的边.(v和w指的是任务,优先级限制v->w指的是v必须在w执行之前完成.)
我们还需要为每个任务添加一条从起点指向该任务的起始顶点(s)的权重为零的边以及一条从该任务的结束顶点到终点(t)的权重为零的边.
这样,每个任务预计的开始时间即为从起点到它的起始顶点的最长距离.

#### 实现
这里实现任务调度问题的关键路径方法将问题规约为寻找无环加权有向图的最长路径问题.它会根据任务调度问题的描述用关键路径的方法构造一副有向图,
然后使用AcyclicLP找到图中的最长路径树,最后打印出各条路径的长度,也就是正好是每个任务开始的时间.

#### 命题U,解决优先级限制下的并行任务调度问题的关键路径法所需的时间为线性级别
证明:
为什么CPM类能够解决问题?算法的正确性依赖于两个因素.
1.在相应的有向无环图中,每条路径都是由任务的起始顶点和结束顶点组成的并由权重为零的优先级限制条件的边分隔---从起点s到任意顶点v的任意路径的长度都是任务v的开始/结束的时间下限,因为这已经是在同一台处理器上顺序完成这些任务最优的排列顺序了.
因此,从起点s到终点t的最长路径就是所有任务完成时间的下限.
2.由最长路径得到的所有开始和结束时间都是可行的---每个任务都只能在优先级限制指定的先导任务完成之后开始,因为它的开始时间就是顶点到它的起始顶点的最长路径的长度.
因此,从起点s到t的最长路径长度就是所有任务完成时间的上限.

## 一般加权有向图中的最短路径问题

接下来,考虑既可能含有环也可能含有负权重的边的加权有向图的最短路径算法.

在只存在正权重的边时,我们的重点在于寻找近路;但当存在负权重的边的时,我们可能会为了经过负权重而绕弯.
这种效应使得我们要将查找"最短"路径的感觉转变为对算法本质的理解.

#### 负权重的环
当我们在研究含有负权重边的有向图时,如果该图中含有一个权重为负的环,那么最短路径的概念就失去意义了.
我们只要围着这个环兜圈子就能得到权重任意短的路径!注意,有向环的所有边的权重并不一定都必须是负的,只要权重之和是负的即可.

> 定义: 加权有向图中的负权重环是一个总权重(环上的所有边的权重之和)为负的有向环.

假设从s到可达的某个顶点v的路径上的某个顶点在一个负权重环上.在这种情况下,从s到v的最短路径是不可能存在的,因为可以用这个负权重环构造权重任意小的路径.
换句话说,在负权重环存在的情况下,最短路径问题是没有意义的.

#### 命题W.当且仅当加权有向图中至少存在一条从s到v的有向路径且所有从s到v的有向路径上的任意顶点都不存在于任何负权重环时,s到v的最短路径才是存在的.

无论是否存在负权重环,从s到可达的其他顶点的一条最短的简单路径都是存在的.

因此,一个定义明确且可以解决加权有向图最短路径问题的算法要能够:
- 对于起点不可达的顶点,最短路径为正无穷
- 对于起点可达但路径上的某个顶点属于一个负权重环上的顶点,最短路径为负无穷
- 对于其他所有顶点,计算最短路径的权重

现在我们解决以下问题:
负权重环的检测,给定的加权有向图中含有负权重环吗?如果有,找到它.
负权重环不可达的单点最短路径,给定一副加权有向图和一个起点s,且从s无法到达任何负权重环,回答"是否存在一条从s到给定的顶点v的有向路径",如果有,找出最短的那条.
总结.尽管在含有环的有向图中最短路径是一个没有意义的问题,而且也无法有效解决在这种有向图中高效找出最短简单路径的问题,在实际应用中仍然需要能够识别其中负权重环.

#### 命题X.Bellman-ford算法.
在任意含有V个顶点的加权有向图中给定起点s,从s无法到达任何负权重环,
以下算法能够解决其中的单点路径问题:将distTo[s]初始化为0,其他distTo[]元素初始化为无穷大.以任意的顺序放松所有边,重复V轮.

证明:
**对于从s可达的任意顶点t,考虑从s到t的一条最短路径:v0->v1->...->vk,其中v0等于s,vk等于t.**
因为负权重环是不可达的,这样的路径是存在的且k不会大于V-1.
我们会通过归纳法证明算法在第i轮之后能够得到s到vi的最短路径.
最简单的情况(i = 0)很容易.
假设对于i命题成立,那么从s到vi的最短路径即为v0->v1->...vi,distTo[vi]就是这条路径的长度.
现在,我们在第i轮中放松所有的顶点,包括vi,因此distTo[vi+1]必然等于distTo[vi]与边vi->vi+1的权重之和.
在第i轮放松之后,distTo[vi+1]必然等于distTo[vi]的边vi->vi+1的权重之和.
它不可能更大,因为在第i轮中放松了所有顶点,包括vi;它也不可能更小,因为它就是路径v0->v1->...->vi+1的长度,也就是最短路径了.
因此,在第i+1轮算法能够得到s到vi+1的路径.

Bellman-Ford算法所需的代码非常少,它基于以下两种其他的数据结构:
- 一条用来保存即将被放松的顶点的队列queue
- 一个由顶点索引的boolean数组onQ[],它用来只是顶点是否已经存在于队列中,以防止将顶点重复加入队列.

首先,将起点s加入队列中,然后进入一个循环,其中每次都从队列中取出一个顶点并将其放松.
要将一个顶点插入队列,需要修改边的松弛中的relax方法的实现,以便将被成功放松的边所指向的顶点加入队列中.
所以这些数据结构能保证:
- 队列中不出现重复的顶点
- 在某一轮中,改变了edgeTo[]和distTo[]的值的所有顶点都会在下一轮中处理.
要完整的实现该算法,我们就需要保证在V轮后算法能够终止.实现它的一种方法是显示记录放松的轮数.

命题Y:对于任意含有V个顶点的加权有向图和给定的顶点s,在最坏的情况下基于队列的Bellman-Ford算法解决最短路径问题(或者找到从s可达的负权重环)所需的时间与EV成正比,空间和V成正比.
证明:如果不存在从s可达的负权重环,算法会根据命题X在进行V-1轮放松操作后结束(因为所有最短路径含有的边数都小于V-1).
如果的确存在一个从s可达的负权重环,那么队列不可能为空.
根据命题X,在第V轮放松之后,edgeTo[]数组必然会包含一条含有一个环的路径(从某个顶点w回到它自己)且该权重必然是负的.
因为w会在路径上出现两次且s到w的第二次出现出的路径长小于s到w的第一次出现的路径长度.
在最坏的情况下,该算法的行为和通用算法相似并会将所有的E条边全部放松V轮.

### 套汇
套汇问题等价于加权有向图中的负权环检测问题.

